"""
采样操作：
单个视图上的采样操作：（其中Sampler只用到邻接关系，没有用到邻接权重；Sampler2和Sampler3分别以两个不同的方式使用权重信息）
    Sampler:  GraphSAGE论文里面的采样操作： 随机采样； 后续等权聚合
    Sampler2: 随机采样，记录边的值； 后续加权聚合
    Sampler3: 带权采样；后续等权聚合
同时在多个视图上的采样操作：
    HINSampler： 在Sampler的基础上修改为多个视图。
"""
import random
import numpy as np


class Sampler(object):
    """
    GraphSAGE论文中采样方法
    """
    def __init__(self, adj_list, self_loop=True):
        self.adj_list = adj_list
        self.layers = []
        self.self_loop = self_loop

    def add_sample_layer(self, num_sample):
        self.layers.append(num_sample)

    def sample_layer(self, nodes, num_sample):
        """
        每一层对应的采样
        self_loop: 是否把自己也算成邻居
        """
        # 第一步：　给每个节点采样
        # to_neigh表示节点的所有邻居，　samp_neigh表示节点采样后的邻居
        # 这里使用简单的随机采样，后续可以改进成复杂的采样
        
        to_neighs = [self.adj_list[int(node)] for node in nodes]
        _set = set
        if not num_sample is None:
            _sample = random.sample
            samp_neighs = [_set(_sample(to_neigh, num_sample,)) if len(to_neigh)>num_sample else to_neigh for to_neigh in to_neighs]
        else:
            samp_neighs = to_neighs
        
        if self.self_loop:
            for i in range(len(nodes)):
                samp_neighs[i].add(nodes[i])

        # 第二步：确定所有涉及到的节点
        unique_nodes_list = list(set.union(*samp_neighs) | set(nodes))

        # unique_nodes = {n:i for i,n in enumerate(unique_nodes_list)}
        unique_nodes = dict(list(zip(unique_nodes_list, list(range(len(unique_nodes_list))))))

        return unique_nodes_list, samp_neighs, unique_nodes

    def sample(self, nodes):
        current_nodes = nodes
        nodes_layers = [(current_nodes,)]
        for num_sample in reversed(self.layers):
            lower_nodes_list, lower_samp_neighs, lower_unique_nodes = self.sample_layer(current_nodes, num_sample)
            nodes_layers.insert(0, (lower_nodes_list, lower_samp_neighs, lower_unique_nodes))
            current_nodes = lower_nodes_list

        return nodes_layers


class HINSampler(object):
    """
    Multi_view
    """
    def __init__(self, adj_lists):
        """
        adj_lists: dict()
        """
        self.adj_lists = adj_lists
        self.layers = []

    def add_sample_layer(self, num_sample):
        self.layers.append(num_sample)

    def sample_layer(self, nodes, adj_list, num_sample=10):
        """
        每一层对应的采样
        """
        # 第一步：　给每个节点采样
        # to_neigh表示节点的所有邻居，　samp_neigh表示节点采样后的邻居
        # 这里使用简单的随机采样，后续可以改进成复杂的采样
        to_neighs = [adj_list[int(node)] for node in nodes]
        _set = set
        if not num_sample is None:
            _sample = random.sample
            samp_neighs = [_set(_sample(to_neigh, num_sample,)) if len(to_neigh)>num_sample else to_neigh for to_neigh in to_neighs]
        else:
            samp_neighs = to_neighs    
        
        # 第二步：确定所有涉及到的节点
        unique_nodes_list = list(set.union(*samp_neighs) | set(nodes))

        # unique_nodes = {n:i for i,n in enumerate(unique_nodes_list)}
        unique_nodes = dict(list(zip(unique_nodes_list, list(range(len(unique_nodes_list))))))

        return unique_nodes_list, samp_neighs, unique_nodes

    def sample_layer_multi_view(self, nodes, num_sample=10):
        """
        return: samp_neighs是一个dict
        """
        unique_nodes_list = set()
        samp_neighs = dict()
        # 从每个view中采样，最后将采样结果综合在一起
        for view, adj in self.adj_lists.items():
            lower_nodes_list, lower_samp_neighs, _ = self.sample_layer(nodes, adj, num_sample)
            samp_neighs[view] = lower_samp_neighs
            unique_nodes_list |= set(lower_nodes_list)
        unique_nodes_list = list(unique_nodes_list)
        unique_nodes = dict(list(zip(unique_nodes_list, list(range(len(unique_nodes_list))))))
        return unique_nodes_list, samp_neighs, unique_nodes

    def sample(self, nodes):
        current_nodes = nodes
        nodes_layers = [(current_nodes,)]
        for num_sample in reversed(self.layers):
            lower_nodes_list, lower_samp_neighs, lower_unique_nodes = self.sample_layer_multi_view(current_nodes, num_sample)
            nodes_layers.insert(0, (lower_nodes_list, lower_samp_neighs, lower_unique_nodes))
            current_nodes = lower_nodes_list

        return nodes_layers

def node_map(nodes, unique_nodes):
    index = [unique_nodes[x] for x in nodes]
    return index
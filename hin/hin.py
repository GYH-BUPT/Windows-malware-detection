import os
import sys
import json
from collections import defaultdict
import pickle as pkl
import numpy as np
import scipy.sparse as sp
from scipy.sparse import vstack


def col_normalize(mat):
    """
    将 列 归一化到1， 在apk-tpl矩阵，相当于降低了被使用多的tpl的权重
    """
    colsum = np.array(np.sum(mat, axis=0), dtype=np.float16)
    c_inv = np.power(colsum, -1).flatten()
    c_inv[np.isinf(c_inv)] = 0
    c_mat_inv = sp.diags(c_inv)
    ret = mat.dot(c_mat_inv)
    return ret

def row_normalize(feats):
    """
    row-normalize matrix.
    """
    rowsum = np.array(np.sum(feats, axis=1), dtype=np.float16)
    r_inv = np.power(rowsum, -1).flatten()
    r_inv[np.isinf(r_inv)] = 0.
    r_mat_inv = sp.diags(r_inv)
    feats = r_mat_inv.dot(feats)
    return feats

def row_argsort(mat, top_n):
    """
    对于输入矩阵，只保留每行top_n个元素
    """
    if type(mat) is not np.ndarray:
        mat = mat.toarray()

    indexs = mat.argsort(1)[:, -top_n:]
    row = [i for i in range(indexs.shape[0]) for _ in range(indexs.shape[1])]
    col = [j for i in indexs for j in i]

    new_mat = np.zeros_like(mat)
    new_mat[row, col] = mat[row, col]
    return sp.csr_matrix(new_mat)


def ajd_mat2list(adj_matrix):
    """
    将邻接矩阵转换成邻接链表
    转换会忽略边的权重，这点后续可以改进; 比如可以考虑直接在邻居矩阵上采样
    """
    adj_list = defaultdict(set)
    for i, col in enumerate(adj_matrix):
        col_np = col.toarray().squeeze()
        if np.sum(col_np) > 0:
            # print("node{}: {} neighbors.".format(i, np.sum(col_np>0)))
            adj_list[i] = set(np.where(col_np>0)[0])
        else: # 只有在当前节点一个邻居都没有的情况下，才会添加自环
            # print("node{}: 0 neighbors. add itself to adj_list[{}]".format(i, i))
            adj_list[i].add(i)
    return adj_list


class Transformer:
    """
    根据design_matrix得到邻接矩阵/邻接表
    """
    def __init__(self,):
        pass

    def get_adj(self, design_matrix, pre_max, post_max):
        """
        获取各meta-path下的视图
        """
        mat = self.preprocess(design_matrix, pre_max)
        adj_matrix = mat * mat.transpose()
        adj_matrix = self.postprocess(adj_matrix, post_max)
        return adj_matrix, ajd_mat2list(adj_matrix) #返回邻接矩阵和邻接表

    def postprocess(self, matrix, max_neigh=20):
        """
        减小节点的度
        """
        mat = matrix.toarray()
        # step1: 对角线元素置0, 去掉自环
        np.fill_diagonal(mat, 0)
        # step2: 将小于0.001的值过滤掉, 去掉关系强度太弱的边
        mat = np.where(mat>1e-3, mat, 0)
        # step3: 限制最大邻居数
        mat = row_argsort(mat, top_n=max_neigh)

        return sp.csr_matrix(mat)
    
    def preprocess(self, matrix, max_neigh=20):
        """
        预处理
        """
        # step1: 列归一化
        matrix = col_normalize(matrix)
        # step2: 行排序，保留前max_neigh个非0
        matrix = row_argsort(matrix, top_n=max_neigh)
        # step3: 行归一化
        matrix = row_normalize(matrix)

        return matrix


def worker(name):
    transfor = Transformer()
    mat = sp.load_npz(os.path.join(data_dir, '{}_feat.npz'.format(name)))
    adj_mat, adj_list = transfor.get_adj(mat, 20, 10)
    with open(os.path.join(data_dir, 'adj_list_app_{}_app.pkl'.format(name)), 'wb') as f:
        pkl.dump(adj_list, f)
    sp.save_npz(os.path.join(data_dir, 'adj_mat_app_{}_app.npz'.format(name)), adj_mat)


if __name__ == '__main__':
    data_dir = '/data/android/exp_data/tesseract'
    # for name in ['tpls', 'url', 'permission', 'component']:
    #     mat = sp.load_npz(os.path.join(data_dir, '{}_feats.npz'.format(name)))
    #     adj_mat, adj_list = transfor.get_adj(mat, 20, 20)
    #     with open(os.path.join(data_dir, 'adj_list_app_{}_app.pkl'.format(name)), 'wb') as f:
    #         pkl.dump(adj_list, f)
    #     sp.save_npz(os.path.join(data_dir, 'adj_mat_app_{}_app.npz'.format(name)), adj_mat)
    # import multiprocessing as mp
    # names = ['author', 'component']
    # pool = mp.Pool(processes=2)
    # pool.map(worker, names)
    # pool.close()
    # pool.join()
    # print("done")

    name = 'author'
    worker(name)